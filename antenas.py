# -*- coding: utf-8 -*-
"""Diseño de Antenas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X6Bjf79H0Lm3RkYiAo8C9CHRXfNLkiNF
"""

import numpy as np
import pandas as pd
import scipy.integrate as integrate
from scipy.special import jn
import matplotlib.pyplot as plt

def Li(L1,τ,n):
  L=np.zeros(n)
  for i in range(n):
    Li=L1*τ**i
    L[i]=Li
  return L
def ΔRi(L,τ,σ):
  ΔR=np.zeros(len(L))
  for i in range(len(L)-1):
    ΔRi=(L[i]-L[i+1])/2*((4*σ)/(1-τ))
    ΔR[i]=ΔRi
  return ΔR

def AntLog(τ,σ,f1,f2,vp):
  c=3*10**8
  B=f2/f1
  Bar=1.1+7.7*(1-τ)**2*((4*σ)/(1-τ))
  Bs=B*Bar
  N=np.floor(1+np.log10(Bs)/np.log10(1/τ))
  L1=1/2*(vp*c/f1)
  LS=L1/4
  L=Li(L1,τ,round(N))
  ΔR=ΔRi(L,τ,σ)
  Iter=[]
  for i in range(len(L)):
    Iter.append(i+1)
    L[i]=round(L[i]*10**3,2)
    ΔR[i]=round(ΔR[i]*10**3,2)
  data={"Elemento (i)":Iter,
        "Li [mm]": L,
        "Ri [mm]": ΔR}
  df=pd.DataFrame(data)
  return B,Bar,Bs,N,LS,df
def AntLogDecrip(τ,σ,f1,f2,vp):
  AL=AntLog(τ,σ,f1,f2,vp)
  print('B= ', round(AL[0],4))
  print('Bar= ',round(AL[1],4))
  print('Bs= ',round(AL[2],4))
  print('N= ',round(AL[3]))
  print('LS= ',round(AL[4]*10**3,2),'mm')
  print(AL[5])

AntLogDecrip(0.965,0.185,2500*10**6,3700*10**6,2/3)#Ejemplo de aplicación

def Rmstrip(εr,fr,h):
  c=3*10**8#Velocidad de la luz
  w=c/(2*fr)*np.sqrt(2/(εr+1))
  εreff=(εr+1)/2+(εr-1)/2*(1+12*(h/w))**(-1/2)
  ΔL=0.412*((εreff+0.3)*(w/h+0.264))/((εreff-0.258)*(w/h+0.8))*h
  L=c/(2*fr*np.sqrt(εreff))-2*ΔL
  Le=L+2*ΔL
  return w, εreff, ΔL, L, Le
def RmstripDescrip(εr,fr,h):
  MSt=Rmstrip(εr,fr,h)
  print('W= ',round(MSt[0]*10**2,3),' cm')#Ancho
  print('εreff= ',round(MSt[1],3))#Constante dieléctrica efectiva
  print('ΔL= ',round(MSt[2]*10**2,3),' cm')#Extensión de la distancia
  print('L= ',round(MSt[3]*10**2,3),' cm')#Distancia
  print('Le=',round(MSt[4]*10**2,3),'cm')#Distancia efectiva

RmstripDescrip(2.2,10*10**9,0.1588*10**(-2))#Ejemplo de aplicación

def Amnp(m,n,p,h,L,w):
    Amnp=((m*np.pi/h)**2+(n*np.pi/L)**2+(p*np.pi/w)**2)**(1/2)
    return Amnp
def fr(m,n,p,h,L,w,εr):
    ε0=8.854*10**(-12)#Permitividad del vacío (F/m)
    μ0=4*10**(-7)*np.pi# Permeabilidad del vacío (H/m)
    fr=1/(2*np.pi*np.sqrt(εr)*np.sqrt(μ0*ε0))*Amnp(m,n,p,h,L,w)
    return fr
def frDM(w,εr,L,h):#L>w>L/2>h
    ε0=8.854*10**(-12)#Permitividad del vacío (F/m)
    μ0=4*10**(-7)*np.pi# Permeabilidad del vacío (H/m)
    MSt=Rmstrip(εr,1,h)
    fr010=fr(0,1,0,h,L,w,εr)
    frc010=1/(2*MSt[4]* np.sqrt(MSt[1]) * np.sqrt(μ0*ε0))
    fr001=fr(0,0,1,h,L,w,εr)
    fr020=fr(0,2,0,h,L,w,εr)
    return fr010,frc010,fr001,fr020
def frDMDescrip(w,εr,L,h):
    DM=frDM(w,εr,L,h)
    print('fr010=',round(DM[0]*10**(-9),3),'GHz')#Frecuencia resonante MT010 sin flecos
    print('frc010=',round(DM[1],3),'GHz')#Frecuencia resonante MT010 con flecos
    print('fr001=',round(DM[2]*10**(-9),3),'GHz')#Frecuencia resonante MT001 sin flecos
    print('fr020=',round(DM[3]*10**(-9),3),'GHz')#Frecuencia resonante MT020 sin flecos

frDMDescrip(0.028,2.2,0.03,0.01)#Ejemplo de aplicación

def kλ(fr):
    c=3*10**8
    λ0=c/fr
    k0=2*np.pi/λ0
    return λ0,k0
def condsucep(w,L,h,εr,fr,FD,y0,w0):
    kλ0=kλ(fr)
    λ0=kλ0[0]
    k0=kλ0[1]
    f=lambda x: np.sin(x)/x
    Si=integrate.quad(f,0,k0*w)
    I1=-2+np.cos(k0*w)+k0*w*Si[0]+np.sin(k0*w)/(k0*w)#Integral sinoidal
    G1=I1/(120*np.pi**2)
    G1a= (w/(120*λ0))*(1-(1/24)*(k0*h)**2)
    B1a=(w/(120*λ0))*(1-0.636*np.log(k0*h))
    g=lambda x: 1/(120*np.pi**2)*(np.sin(k0*w/2*np.cos(x))/np.cos(x))**2*jn(0,k0*L*np.sin(x))*np.sin(x)**3#Integral con funciones de Bessel del primer tipo
    G12=integrate.quad(g,0,np.pi)
    Rin0=0
    Rin=0
    MSt=Rmstrip(εr,fr,h)
    if (FD==0 or FD==1):#0 antisimétrico, 1 simétrico
          Rin0=1/(2*(G1+(-1)**FD*G12[0]))
          Rin=Rin0*np.cos(np.pi/L*y0)**2
    if (w0/h<=1):
      Zc=60/np.sqrt(MSt[1])*np.log((8*h)/w0+w0/(4*h))#Impedancia característica
    else:
      Zc=120*np.pi/(np.sqrt(MSt[1])*(w0/h+1.393+0.667*np.log(w0/h+1.444)))
    return G1, G1a, G12[0], Rin0, Rin, Zc, B1a, I1
def condsucepDescrip(w,L,h,εr,fr,FD,y0,w0):
    GB=condsucep(w,L,h,εr,fr,FD,y0,w0)
    print('G1= ',round(GB[0],5), 'S')#Conductividad de ranura
    print('G1a= ',round(GB[1],5),'S')#Conductividad de ranura aproximada
    print('G12= ',round(GB[2],8), 'S')#Conductancia mutua
    if (FD==0 or FD==1):#0 antisimétrico, 1 simétrico
      print('Rin0= ', round(GB[3],4), 'Ω')#Resistencia de entrada a la distancia y=0
      print('Rin= ',round(GB[4]),'Ω')#Resistencia de entrada a la distancia y=y0
    else:
      print('Tipo de resonancia no especificada')
    print('Zc= ',round(GB[5],2),'Ω')
    print('B1= ',round(GB[6],5), 'S')#Suceptancia de ranura aproximada

condsucepDescrip(1.186*10**(-2),0.906*10**(-2),0.1588*10**(-2),2.2,10*10**9,0,0.3126*10**(-2),0.31*10**(-2))#Ejemplo de aplicación

def dB(arg):
    dB=10*np.log10(arg)
    return dB
def RectMStrip(w,L,h,εr,fr,FD,y0,w0,Le):
    kλ0=kλ(fr)
    λ0=kλ0[0]
    k0=kλ0[1]
    GB=condsucep(w,L,h,εr,fr,FD,y0,w0)
    h=lambda x,y: (np.sin(k0*w*np.cos(x)/2)/np.cos(x))**2*np.sin(x)**3*np.cos(k0*Le/2*np.sin(x)*np.sin(y))**2
    I2=integrate.dblquad(h,0,np.pi,0,np.pi)
    g12=GB[2]/GB[0]
    DAF=2/(1+g12)
    D0=(2*np.pi*w/λ0)**2*1/GB[7]
    D2a=D0*DAF
    D2=(2*np.pi*w/λ0)**2*np.pi/I2[0]
    return DAF,D0,D2a,D2
def RectMStripDescrip(w,L,h,εr,fr,FD,y0,w0,Le):
    RMSt=RectMStrip(w,L,h,εr,fr,FD,y0,w0,Le)
    print('DAF= ',round(RMSt[0],4),'= ',round(dB(RMSt[0]),4),'dB')#Directividad del factor de arreglo
    print('D0= ',round(RMSt[1],3),'= ',round(dB(RMSt[1]),3),'dB')#Directividad de ranura simple
    print('D2a= ',round(RMSt[2],4),'=',round(dB(RMSt[2]),4),'dB')#Directividad lateral aproximada
    print('D2= ',round(RMSt[3],4),'=',round(dB(RMSt[3]),3),'dB')#Directividad lateral

RectMStripDescrip(1.186*10**(-2),0.906*10**(-2),0.1588*10**(-2),2.2,10*10**9,0,0.3126*10**(-2),0.31*10**(-2),1.0575*10**(-2))#Ejemplo de aplicación

def CircPatch(h,εr,fr):
  F=8.791*10**9/(fr*np.sqrt(2.2))
  a=F/(1+(2*h)/(np.pi*εr*F)*(np.log(np.pi*F/(2*h))+1.7726))**(1/2)
  return F,a
def Plane(θ,f,lb):
  fm=np.abs(f)
  z =dB(f/np.max(fm))
  fig = plt.figure()
  ax = fig.add_subplot(111, projection='polar')
  ax.set_theta_zero_location("N")  # 'N' = Norte (90°)
  ax.set_theta_direction(1)
  ax.plot(θ, z,label=lb)
  ax.grid(True)
  ax.set_rlabel_position(0)
  ax.set_rlim(-120, 0)
  ax.legend()
  plt.show()
def CircPatchDecrip(h,εr,fr):#h en cm
  kλ0=kλ(fr)
  k0=kλ0[1]
  CP=CircPatch(h,εr,fr)
  θ = np.linspace(-np.pi/2, np.pi/2, 50)
  E0=-1j*2*np.pi*fr
  J02=jn(0,k0*CP[0]*np.sin(θ))+jn(2,k0*CP[0]*np.sin(θ))
  j02=jn(0,k0*CP[0]*np.sin(θ))-jn(2,k0*CP[0]*np.sin(θ))
  E=1j*(k0*CP[0]*h*10**(-2)*E0*np.exp(-1j*k0*CP[1])/(2*CP[1]))
  Eθ1=E*j02
  Eθ2=E*np.cos(θ)*J02
  Plane(θ,Eθ1,"Plano-E")
  Plane(θ,Eθ2,"Plano-H")
  print('F= ',round(CP[0],3))#factor
  print('a= ',round(CP[1],3),'cm')#radio del parche

CircPatchDecrip(0.1588,2.2,10*10**9)#Ejemplo de aplicación

def QF(h,fr,tgδ,σ,εr):
  kλ0=kλ(fr)
  k0=kλ0[1]
  μ0=4*10**(-7)*np.pi# Permeabilidad del vacío (H/m)
  Qc=h*np.sqrt(np.pi*fr*μ0*σ)
  Qd=1/tgδ
  MSt=Rmstrip(εr,fr,h)
  CP=CircPatch(h,εr,fr)
  f=lambda x:(k0*CP[0])**2/480*((jn(0,k0*CP[0]*np.sin(x))-jn(2,k0*CP[0]*np.sin(x)))**2+np.cos(x)**2*(jn(0,k0*CP[0]*np.sin(x))+jn(2,k0*CP[0]*np.sin(x)))**2)*np.sin(x)
  Grad=integrate.quad(f,0,np.pi/2)
  Gl=Grad[0]*10**(9)/MSt[0]
  K=MSt[3]/4
  Qrad=(4*np.pi*fr*εr)/(h*Gl)*K
  Qt=(1/Qrad+1/Qc+1/Qd)**(-1)
  ecdsw=Qt/Qrad
  return Qc, Qd, Qrad, Qt, ecdsw
def QFDescrip(h,fr,tgδ,σ,εr):
  Q=QF(h,fr,tgδ,σ,εr)
  print('Qc= ',round(Q[0],3))#Factor de calidad debido a las pérdidas de conducción
  print('Qd=', round(Q[1],3))#Factor de calidad debido a las pérdidas de dieléctrico
  print('Qrad= ',round(Q[2],3))#Factor de calidad debido a la radiación
  print('Qt= ',round(Q[3],3))#Factor de calidad total
  print('ecdsw= ',round(Q[4],3))#Eficiencia de radiación

QFDescrip(0.127*10**(-2),1.6*10**9,0.0018,10**7,10.2)#Ejemplo de aplicación

def QBW(h,εr,f0,VSWR,pfreq):
  Qt=(VSWR-1)/(pfreq*np.sqrt(VSWR))
  rwL=1+1/Qt
  f1=f0/np.sqrt(rwL)
  f2=f0*np.sqrt(rwL)
  BW=f2-f1
  BWa=1/np.sqrt(εr)
  return Qt,f1,f2,BW,BWa,rwL
def QBWDecrip(h,εr,f0,VSWR,pfreq):
  QB=QBW(h,εr,f0,VSWR,pfreq)
  print('Qt= ',round(QB[0],2))#Factor de calidad total
  print('f1= ',round(QB[1]*10**(-9),3),'GHz')#Frecuencia de corte inferior
  print('f2= ',round(QB[2]*10**(-9),3),'GHz')#Frecuencia de corte superior
  print('BW= ',round(QB[3]*10**(-9),3),'GHz')#Ancho de banda
  print('BWa= ',round(QB[4],3),'GHz')#Ancho de banda aproximada
  print('L/W= ',round(QB[5],2))#Razón relativa entre longitudes

QBWDecrip(0.1588*10**(-2),2.2,10*10**9,2,0.05)#Ejemplo de aplicación